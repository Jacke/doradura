#!/usr/bin/env python3
"""
YouTube Cookie Manager — aiohttp server + Playwright browser automation.

Manages YouTube cookies automatically:
1. First login via noVNC (admin logs in visually)
2. Cookie refresh every 30 minutes (headless)
3. Exports cookies in Netscape format for yt-dlp

API endpoints:
  POST /api/login_start    — Start login session (Xvfb + Chromium + noVNC)
  POST /api/login_stop     — Stop login, export cookies
  GET  /api/status         — Cookie manager status
  POST /api/export_cookies — Force cookie re-export
"""

import asyncio
import logging
import os
import subprocess
from datetime import datetime, timezone

from aiohttp import web

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

COOKIES_FILE = os.environ.get("YTDL_COOKIES_FILE", "/data/youtube_cookies.txt")
BROWSER_PROFILE_DIR = os.environ.get("BROWSER_PROFILE_DIR", "/data/browser_profile")
REFRESH_INTERVAL = int(os.environ.get("COOKIE_REFRESH_INTERVAL", "1800"))  # 30 min
LOGIN_TIMEOUT = int(os.environ.get("COOKIE_LOGIN_TIMEOUT", "900"))  # 15 min
API_PORT = int(os.environ.get("COOKIE_MANAGER_PORT", "9876"))
API_HOST = os.environ.get("COOKIE_MANAGER_HOST", "127.0.0.1")
NOVNC_HOST = os.environ.get("NOVNC_HOST", "")
NOVNC_PORT = int(os.environ.get("NOVNC_PORT", "6080"))
VNC_PORT = 5900
DISPLAY = ":99"
CHROMIUM_PATH = os.environ.get(
    "PLAYWRIGHT_CHROMIUM_EXECUTABLE_PATH", "/usr/bin/chromium-browser"
)

# Required YouTube/Google cookies that indicate a valid session
REQUIRED_COOKIES = {"SID", "HSID", "SSID", "APISID", "SAPISID"}

# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [cookie-manager] %(levelname)s %(message)s",
    datefmt="%H:%M:%S",
)
log = logging.getLogger("cookie-manager")

# ---------------------------------------------------------------------------
# Global state
# ---------------------------------------------------------------------------

status = {
    "login_active": False,
    "login_started_at": None,
    "last_refresh": None,
    "last_refresh_success": None,
    "cookie_count": 0,
    "needs_relogin": False,
    "profile_exists": False,
    "last_error": None,
}

login_state = {
    "browser": None,
    "context": None,
    "xvfb_proc": None,
    "vnc_proc": None,
    "novnc_proc": None,
}


# ---------------------------------------------------------------------------
# Cookie export
# ---------------------------------------------------------------------------

def format_netscape_cookie(cookie: dict) -> str:
    """Convert a Playwright cookie dict to a Netscape cookie file line."""
    domain = cookie.get("domain", "")
    subdomain = "TRUE" if domain.startswith(".") else "FALSE"
    path = cookie.get("path", "/")
    secure = "TRUE" if cookie.get("secure", False) else "FALSE"
    expires = str(int(cookie.get("expires", 0)))
    name = cookie.get("name", "")
    value = cookie.get("value", "")
    return f"{domain}\t{subdomain}\t{path}\t{secure}\t{expires}\t{name}\t{value}"


async def export_cookies_from_profile() -> int:
    """Launch headless browser with saved profile, extract and write cookies."""
    from playwright.async_api import async_playwright

    if not os.path.exists(BROWSER_PROFILE_DIR):
        raise FileNotFoundError(f"Browser profile not found: {BROWSER_PROFILE_DIR}")

    cookie_count = 0

    async with async_playwright() as p:
        context = await p.chromium.launch_persistent_context(
            user_data_dir=BROWSER_PROFILE_DIR,
            executable_path=CHROMIUM_PATH,
            headless=True,
            args=[
                "--no-sandbox",
                "--disable-gpu",
                "--disable-dev-shm-usage",
                "--disable-extensions",
            ],
        )

        try:
            # Navigate to YouTube to refresh session
            page = context.pages[0] if context.pages else await context.new_page()
            await page.goto(
                "https://www.youtube.com",
                wait_until="networkidle",
                timeout=30000,
            )

            # Extract cookies
            cookies = await context.cookies(
                ["https://www.youtube.com", "https://accounts.google.com"]
            )
        finally:
            await context.close()

    # Filter relevant cookies
    relevant = [
        c
        for c in cookies
        if any(
            d in c.get("domain", "")
            for d in ["youtube.com", "google.com", "googleapis.com"]
        )
    ]

    # Write Netscape format
    lines = [
        "# Netscape HTTP Cookie File",
        f"# Generated by cookie_manager.py at {datetime.now(timezone.utc).isoformat()}",
        "",
    ]
    for c in relevant:
        lines.append(format_netscape_cookie(c))

    content = "\n".join(lines) + "\n"

    # Atomic write
    tmp_path = COOKIES_FILE + ".tmp"
    with open(tmp_path, "w") as f:
        f.write(content)
    os.rename(tmp_path, COOKIES_FILE)
    os.chmod(COOKIES_FILE, 0o644)

    cookie_count = len(relevant)
    cookie_names = {c["name"] for c in relevant}
    has_session = bool(REQUIRED_COOKIES & cookie_names)

    log.info(
        "Exported %d cookies (%s session cookies)",
        cookie_count,
        "has" if has_session else "NO",
    )

    return cookie_count


def check_session_valid(cookie_count: int) -> bool:
    """Check if the exported cookies contain valid session data."""
    if cookie_count < 5:
        return False
    # Read cookie file and check for required cookies
    try:
        with open(COOKIES_FILE, "r") as f:
            content = f.read()
        for name in REQUIRED_COOKIES:
            if f"\t{name}\t" in content:
                return True
    except OSError:
        pass
    return False


# ---------------------------------------------------------------------------
# Login flow (visual via noVNC)
# ---------------------------------------------------------------------------

def _kill_proc(proc):
    """Safely kill a subprocess."""
    if proc and proc.poll() is None:
        try:
            proc.terminate()
            proc.wait(timeout=5)
        except (subprocess.TimeoutExpired, OSError):
            try:
                proc.kill()
            except OSError:
                pass


async def start_login() -> dict:
    """Start visual login session: Xvfb + Chromium + x11vnc + noVNC."""
    from playwright.async_api import async_playwright

    if status["login_active"]:
        return {"error": "Login session already active"}

    log.info("Starting login session...")

    # Ensure profile dir exists
    os.makedirs(BROWSER_PROFILE_DIR, exist_ok=True)

    # 1. Start Xvfb
    xvfb_proc = subprocess.Popen(
        ["Xvfb", DISPLAY, "-screen", "0", "1280x720x24"],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    login_state["xvfb_proc"] = xvfb_proc
    await asyncio.sleep(1)  # Wait for Xvfb to start

    if xvfb_proc.poll() is not None:
        return {"error": "Failed to start Xvfb"}

    # 2. Launch Playwright Chromium in headed mode
    os.environ["DISPLAY"] = DISPLAY

    pw = await async_playwright().start()
    login_state["browser"] = pw

    context = await pw.chromium.launch_persistent_context(
        user_data_dir=BROWSER_PROFILE_DIR,
        executable_path=CHROMIUM_PATH,
        headless=False,
        args=[
            "--no-sandbox",
            "--disable-gpu",
            "--disable-dev-shm-usage",
            "--start-maximized",
        ],
        viewport={"width": 1280, "height": 720},
    )
    login_state["context"] = context

    # Navigate to Google login
    page = context.pages[0] if context.pages else await context.new_page()
    await page.goto(
        "https://accounts.google.com/ServiceLogin?continue=https://www.youtube.com/",
        timeout=30000,
    )

    # 3. Start x11vnc
    vnc_proc = subprocess.Popen(
        [
            "x11vnc",
            "-display", DISPLAY,
            "-nopw",
            "-forever",
            "-rfbport", str(VNC_PORT),
            "-shared",
        ],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    login_state["vnc_proc"] = vnc_proc
    await asyncio.sleep(0.5)

    # 4. Start noVNC websockify
    novnc_proc = subprocess.Popen(
        [
            "websockify",
            "--web=/opt/novnc",
            str(NOVNC_PORT),
            f"localhost:{VNC_PORT}",
        ],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    login_state["novnc_proc"] = novnc_proc
    await asyncio.sleep(0.5)

    # Update status
    status["login_active"] = True
    status["login_started_at"] = datetime.now(timezone.utc).isoformat()

    # Build noVNC URL
    host = NOVNC_HOST or "localhost"
    novnc_url = f"http://{host}:{NOVNC_PORT}/vnc.html?autoconnect=true"

    log.info("Login session started. noVNC URL: %s", novnc_url)

    # Schedule auto-timeout
    asyncio.get_running_loop().call_later(LOGIN_TIMEOUT, _auto_stop_login)

    return {"status": "ok", "novnc_url": novnc_url}


def _auto_stop_login():
    """Auto-stop login session after timeout."""
    if status["login_active"]:
        log.warning("Login session timed out after %d seconds", LOGIN_TIMEOUT)
        asyncio.ensure_future(stop_login())


async def stop_login() -> dict:
    """Stop login session, export cookies, cleanup."""
    if not status["login_active"]:
        return {"error": "No active login session"}

    log.info("Stopping login session...")

    result = {"status": "ok", "cookies_exported": False, "cookie_count": 0}

    # Export cookies before closing
    try:
        context = login_state.get("context")
        if context:
            cookies = await context.cookies(
                ["https://www.youtube.com", "https://accounts.google.com"]
            )
            relevant = [
                c
                for c in cookies
                if any(
                    d in c.get("domain", "")
                    for d in ["youtube.com", "google.com", "googleapis.com"]
                )
            ]

            # Write Netscape format
            lines = [
                "# Netscape HTTP Cookie File",
                f"# Generated by cookie_manager.py at {datetime.now(timezone.utc).isoformat()}",
                "",
            ]
            for c in relevant:
                lines.append(format_netscape_cookie(c))

            content = "\n".join(lines) + "\n"
            tmp_path = COOKIES_FILE + ".tmp"
            with open(tmp_path, "w") as f:
                f.write(content)
            os.rename(tmp_path, COOKIES_FILE)
            os.chmod(COOKIES_FILE, 0o644)

            result["cookies_exported"] = True
            result["cookie_count"] = len(relevant)

            status["cookie_count"] = len(relevant)
            status["last_refresh"] = datetime.now(timezone.utc).isoformat()
            status["last_refresh_success"] = True
            status["needs_relogin"] = not check_session_valid(len(relevant))
            status["last_error"] = None

            log.info("Exported %d cookies after login", len(relevant))
    except Exception as e:
        log.error("Failed to export cookies after login: %s", e)
        result["error"] = str(e)
        status["last_error"] = str(e)

    # Cleanup: close browser and display stack
    try:
        context = login_state.get("context")
        if context:
            await context.close()
    except Exception:
        pass

    try:
        browser = login_state.get("browser")
        if browser:
            await browser.stop()
    except Exception:
        pass

    _kill_proc(login_state.get("novnc_proc"))
    _kill_proc(login_state.get("vnc_proc"))
    _kill_proc(login_state.get("xvfb_proc"))

    # Reset state
    login_state.update({
        "browser": None,
        "context": None,
        "xvfb_proc": None,
        "vnc_proc": None,
        "novnc_proc": None,
    })

    status["login_active"] = False
    status["login_started_at"] = None

    log.info("Login session stopped")

    return result


# ---------------------------------------------------------------------------
# Refresh loop
# ---------------------------------------------------------------------------

async def refresh_loop():
    """Background task: refresh cookies every REFRESH_INTERVAL seconds."""
    log.info("Cookie refresh loop started (interval: %ds)", REFRESH_INTERVAL)

    # Initial delay — give bot time to start
    await asyncio.sleep(30)

    while True:
        # Check if profile exists
        status["profile_exists"] = os.path.exists(BROWSER_PROFILE_DIR)

        if status["login_active"]:
            log.debug("Skipping refresh — login session active")
            await asyncio.sleep(60)
            continue

        if not status["profile_exists"]:
            status["needs_relogin"] = True
            log.warning("No browser profile found — need initial login")
            await asyncio.sleep(REFRESH_INTERVAL)
            continue

        log.info("Running scheduled cookie refresh...")

        try:
            count = await export_cookies_from_profile()

            status["last_refresh"] = datetime.now(timezone.utc).isoformat()
            status["last_refresh_success"] = True
            status["cookie_count"] = count
            status["last_error"] = None

            if not check_session_valid(count):
                status["needs_relogin"] = True
                log.warning("Session appears expired — needs re-login")
            else:
                status["needs_relogin"] = False
                log.info("Cookie refresh successful: %d cookies", count)

        except Exception as e:
            status["last_refresh"] = datetime.now(timezone.utc).isoformat()
            status["last_refresh_success"] = False
            status["last_error"] = str(e)
            status["needs_relogin"] = True
            log.error("Cookie refresh failed: %s", e)

        await asyncio.sleep(REFRESH_INTERVAL)


# ---------------------------------------------------------------------------
# HTTP API
# ---------------------------------------------------------------------------

async def handle_login_start(request):
    result = await start_login()
    return web.json_response(result)


async def handle_login_stop(request):
    result = await stop_login()
    return web.json_response(result)


async def handle_status(request):
    status["profile_exists"] = os.path.exists(BROWSER_PROFILE_DIR)
    status["cookies_exist"] = os.path.exists(COOKIES_FILE)
    return web.json_response(status)


async def handle_export_cookies(request):
    try:
        count = await export_cookies_from_profile()
        status["last_refresh"] = datetime.now(timezone.utc).isoformat()
        status["last_refresh_success"] = True
        status["cookie_count"] = count
        status["last_error"] = None
        status["needs_relogin"] = not check_session_valid(count)
        return web.json_response({"success": True, "cookie_count": count})
    except Exception as e:
        status["last_error"] = str(e)
        return web.json_response({"success": False, "error": str(e)}, status=500)


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

async def on_startup(app):
    """Start refresh loop on server startup."""
    app["refresh_task"] = asyncio.ensure_future(refresh_loop())


async def on_cleanup(app):
    """Cleanup on server shutdown."""
    task = app.get("refresh_task")
    if task:
        task.cancel()
        try:
            await task
        except asyncio.CancelledError:
            pass

    # Stop login if active
    if status["login_active"]:
        await stop_login()


def main():
    log.info("Cookie Manager starting on %s:%d", API_HOST, API_PORT)
    log.info("  Cookies file: %s", COOKIES_FILE)
    log.info("  Browser profile: %s", BROWSER_PROFILE_DIR)
    log.info("  Refresh interval: %ds", REFRESH_INTERVAL)
    log.info("  Chromium path: %s", CHROMIUM_PATH)

    app = web.Application()
    app.router.add_post("/api/login_start", handle_login_start)
    app.router.add_post("/api/login_stop", handle_login_stop)
    app.router.add_get("/api/status", handle_status)
    app.router.add_post("/api/export_cookies", handle_export_cookies)

    app.on_startup.append(on_startup)
    app.on_cleanup.append(on_cleanup)

    web.run_app(app, host=API_HOST, port=API_PORT, print=None)


if __name__ == "__main__":
    main()
